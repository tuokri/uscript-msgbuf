// Generated by uscript_msgbuf_generator. DO NOT EDIT.
class {{ class_name }} extends Object
    abstract
    notplaceable;

enum MessageType
{
    {{ uscript_message_type_prefix }}_None,
{% for message in messages %}
    {{ uscript_message_type_prefix }}_{{ message.name }},
{% endfor %}
};

// Describes the wire format used by this library.
struct Packet
{
    // Total size of this packet. Packets larger than 255 are sent as multipart
    // packets. multipart packets must be sent in a sequence, until all parts
    // are sent. multipart parsing is interrupted if single-part messages are
    // sent while a multipart message is being parsed. To indicate the end of
    // multipart sequence, a packet with an empty payload with the following values
    // should be sent: Size=0, Part=0, Type=0 (None).
    var byte Size;

    // 255 for single-part messages. 0-254 for multipart messages. Incremented
    // for each part. Parts must be sent in an order that matches this field.
    // The final multipart sequence indicator message has Part set to 0.
    var byte Part;

    // Byte field. Maximum number of supported messages is 254.
    // 0 is reserved for None.
    var MessageType Type;

    // Payload bytes. Contains an encoded MessageType message.
    var byte Payload[252];
};

struct Message
{
    // TODO: is this unneeded overhead?
    var MessageType Type;
    var bool HasStaticSize;
    var byte StaticSize;
    var bool AlwaysSinglePart;
};

{% for message in messages %}
struct {{ message.name }} extends Message
{
{% for field in message.fields %}
    var {{ field.type }} {{ capitalize(field.name) }};
{% endfor %}
};

{% endfor -%}

{% for message in messages %}
{% if message.always_single_part %}
// Encode {{ message.name }} to bytes. Guaranteed to fit in a single packet.
static final function byte {{ message.name }}_ToBytes(
    const out {{ message.name }} Msg,
    out byte Bytes[255])
{
    {% set sz = message.static_size %}
    {% set x = 0 %}
    {% include "uscript_packet_header.jinja" %}
    {% set x = var("x", "get") %}

    // Packet payload.
    {%- for field in message.fields -%}

    {%- if field.type == "int" %}
    {% include "uscript_static_bytes.jinja" %}
    {% set x = var("x", "get") %}
    {% endif -%}

{%- endfor %}

    return {{ x }};
}
{% endif %}

// Encode {{ message.name }} to bytes. Returns the total number of bytes.
{% if message.always_single_part %}
// NOTE: This message is always guaranteed to fit in a single packet.
// {{ message.name }}_ToBytes() should be used over this function.
{% endif %}
static final function int {{ message.name }}_ToMultiBytes(
    const out {{ message.name }} Msg,
    out array<byte> Bytes)
{
{% if message.always_single_part %}
    local byte B[255];
    local int X;
    X = {{ message.name }}_ToBytes(Msg, B);
    Bytes[0] = 1; // TODO
    return X;
{% else %}
    return -1;
{% endif %}
}

// Decode single-part {{ message.name }} from bytes.
static final function {{ message.name }}_FromBytes(
    out {{ message.name }} Msg,
    const out byte Bytes[255])
{
{% set x = 3 %}
{% if message.always_single_part %}
    {% set sz = message.static_size %}
{% else %}
    {% set sz = 255 %}
{% endif -%}

{%- for field in message.fields %}
    Msg.{{ field.name }} = (
           (Bytes[{{ pad(x, sz) }}{{ x }}]        & 0xff)
        {% set x = x + 1 %}
        | ((Bytes[{{ pad(x, sz) }}{{ x }}] <<  8) & 0xff)
        {% set x = x + 1 %}
        | ((Bytes[{{ pad(x, sz) }}{{ x }}] << 16) & 0xff)
        {% set x = x + 1 %}
        | ((Bytes[{{ pad(x, sz) }}{{ x }}] << 24) & 0xff)
        {% set x = x + 1 %}
    );
{% endfor %}
}

// Decode {{ message.name }} from bytes. Decodes both, single-part and multipart messages.
static final function {{ message.name }}_FromMultiBytes(
    out {{ message.name }} Msg,
    const out array<byte> Bytes)
{
}

{% endfor %}
