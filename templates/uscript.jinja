// Generated by uscript_msgbuf_generator. DO NOT EDIT.
class {{ class_name }} extends Object
    abstract
    notplaceable;

enum MessageType
{
    {{ uscript_message_type_prefix }}_None,
{% for message in messages %}
    {{ uscript_message_type_prefix }}_{{ message.name }},
{% endfor %}
};

struct ByteWrapper
{
    var byte Bytes[255];
}

// Describes the wire format used by this library.
struct Packet
{
    // Total size of this packet. Packets larger than 255 are sent as multipart
    // packets. multipart packets must be sent in a sequence, until all parts
    // are sent. multipart parsing is interrupted if single-part messages are
    // sent while a multipart message is being parsed. To indicate the end of
    // multipart sequence, a packet with an empty payload with the following values
    // should be sent: Size=0, Part=0, Type=0 (None).
    var byte Size;

    // 255 for single-part messages. 0-254 for multipart messages. Incremented
    // for each part. Parts must be sent in an order that matches this field.
    // The final multipart sequence indicator message has Part set to 0.
    var byte Part;

    // Byte field. Maximum number of supported messages is 254.
    // 0 is reserved for None.
    var MessageType Type;

    // Payload bytes. Contains an encoded MessageType message.
    var byte Payload[252];
};

struct Message
{
    // TODO: is this unneeded overhead?
    var MessageType Type;
    var bool HasStaticSize;
    var byte StaticSize;
    var bool AlwaysSinglePart;
};

{% for message in messages %}
struct {{ message.name }} extends Message
{
{% for field in message.fields %}
    var {{ field.type }} {{ capitalize(field.name) }};
{% endfor %}
};

{% endfor %}

{% for message in messages %}
{% if message.always_single_part %}
// Encode {{ message.name }} to bytes. Guaranteed to fit in a single packet.
static final function byte {{ message.name }}_ToBytes(
    const out {{ message.name }} Msg,
    out byte Bytes[255])
{
    {% set sz = message.static_size %}
    {% set x = 0 %}
    Bytes[{{ pad(x, sz) }}{{ x }}] = {{ sz }};
    {% set x = x + 1 %}
    Bytes[{{ pad(x, sz) }}{{ x }}] = {{ 0 }};
    {% set x = x + 1 %}
    Bytes[{{ pad(x, sz) }}{{ x }}] = byte({{ uscript_message_type_prefix }}_{{ message.name }});
    {% set x = x + 1 -%}

    {%- for field in message.fields -%}

    {%- if field.type == "int" %}
    {% include "uscript_static_bytes.jinja" %}
    {% endif -%}

    {%- endfor %}

    return {{ x }};
}
{% endif %}

// Encode {{ message.name }} to bytes. Returns 255 if the message fits in a single packet.
// For multipart messages, returns the number of parts (2-254).
{% if message.always_single_part %}
// NOTE: This message is always guaranteed to fit in a single packet.
// {{ message.name }}_ToBytes() should be used over this function.
{% endif %}
static final function byte {{ message.name }}_ToMultiBytes(
    const out {{ message.name }} Msg,
    out array<ByteWrapper> Bytes)
{
    return 255;
}

// Decode single-part {{ message.name }} from bytes.
static final function {{ message.name }}_FromBytes(
    out {{ message.name }} Msg,
    const out byte Bytes[255])
{
}

// Decode {{ message.name }} from bytes. Decodes both, single-part and multipart messages.
static final function {{ message.name }}_FromMultiBytes(
    out {{ message.name }} Msg,
    const out array<ByteWrapper> Bytes)
{
}

{% endfor %}
