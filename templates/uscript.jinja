// Generated by uscript_msgbuf_generator. DO NOT EDIT.
class {{ class_name }} extends Object
    abstract
    notplaceable;

const HEADER_SIZE = {{ header_size }};
const PAYLOAD_SIZE = {{ payload_size }};
const PACKET_SIZE = {{ packet_size }};

enum MessageType
{
    {{ uscript_message_type_prefix }}_None,
{% for message in messages %}
    {{ uscript_message_type_prefix }}_{{ message.name }},
{% endfor %}
};

// Describes the wire format used by this library.
struct Packet
{
    // Total size of this packet. Packets larger than 255 are sent as multipart
    // packets. multipart packets must be sent in a sequence, until all parts
    // are sent. multipart parsing is interrupted if single-part messages are
    // sent while a multipart message is being parsed. To indicate the end of
    // multipart sequence, a packet with an empty payload with the following values
    // should be sent: Size=0, Part=0, Type=0 (None).
    var byte Size;

    // 255 for single-part messages. 0-254 for multipart messages. Incremented
    // for each part. Parts must be sent in an order that matches this field.
    // The final multipart sequence indicator message has Part set to 0.
    var byte Part;

    // Byte field. Maximum number of supported messages is 254.
    // 0 is reserved for None.
    var MessageType Type;

    // Payload bytes. Contains an encoded MessageType message.
    var byte Payload[PAYLOAD_SIZE];
};

struct Message
{
    // TODO: is this unneeded overhead?
    var MessageType Type;
    var bool HasStaticSize;
    var byte StaticSize;
    var byte StaticPart;
    var bool AlwaysSinglePart;
};

{% for message in messages %}
struct {{ message.name }} extends Message
{
{% for field in message.fields %}
    var {{ field.type }} {{ capitalize(field.name) }};
{% endfor %}
};

{% endfor -%}

{% for message in messages %}
{% if message.always_single_part %}
// Encode {{ message.name }} to bytes. Guaranteed to fit in a single packet.
static final function byte {{ message.name }}_ToBytes(
    const out {{ message.name }} Msg,
    out byte Bytes[PACKET_SIZE])
{
    {% if message.has_float_fields %}
    {% include "uscript_float_coding_variables.jinja" %}
    {% endif -%}

    {%- set sz = message.static_size %}
    {% set x = 0 %}
    {% include "uscript_encode_static_packet_header.jinja" %}
    {% set x = var("x", "get") %}

    // Encode packet payload.
    {%- for field in message.fields %}
    // Field: {{ field.name }}.
    {%- if field.type == "int" %}
    {% include "uscript_encode_static_int.jinja" %}
    {% set x = var("x", "get") -%}

    {%- else if field.type == "float" %}
    {% include "uscript_encode_static_float.jinja" %}
    {% set x = var("x", "get") -%}

    {%- else if field.type == "byte" %}
    Bytes[{{ pad(x, sz) }}{{ x }}] = Msg.{{ field.name }};

    {%- else -%}
    {{ error("invalid type: '", field.type, "' in ", message.name, "_ToBytes") }}

    {%- endif -%}

{%- endfor %}

    return {{ x }};
}
{% endif %}

// Encode {{ message.name }} to bytes. If the message does not fit
// in a single packet, the sender is responsible for splitting the
// message into multiple packets. The output of this function is valid
// input for {{ message.name }}_FromMultiBytes.
{% if message.always_single_part %}
// NOTE: This message is always guaranteed to fit in a single packet.
// {{ message.name }}_ToBytes() should be used over this function.
{% endif %}
static final function {{ message.name }}_ToMultiBytes(
    const out {{ message.name }} Msg,
    out array<byte> Bytes)
{
{% if message.has_string_fields %}
    {% include "uscript_string_encoding_variables.jinja" %}
{% endif %}
{% if message.always_single_part %} {# Just copy buffer for single-part messages. #}
{% set sz = message.static_size %}
    local byte B[PACKET_SIZE];
    Bytes.Length = {{ sz }};
    {{ message.name }}_ToBytes(Msg, B);
{% for i in range(sz) %}
    Bytes[{{ pad(i, sz) }}{{ i }}] = B[{{ pad(i, sz) }}{{ i }}];
{% endfor %}
{% else %} {# Multipart messages. #}

    // Encode packet payload.
{% set sz = message.static_part %}
{% if message.has_float_fields %}
    {% include "uscript_float_coding_variables.jinja" %}
{% endif %}
    local int I;
    I = 1; // Skip size until it's known.
    // Reserve at least static_part bytes. Grow dynamically if needed.
    Bytes.Length = {{ sz }};
    {% include "uscript_encode_dynamic_packet_header.jinja" %}
{%- for field in message.fields %}
    // Field: {{ field.name }}.
{%- if field.type == "int" %}
    {% include "uscript_encode_dynamic_int.jinja" %}
{% else if field.type == "byte" %}
    Bytes[I++] = Msg.{{ field.name }};
{% else if field.type == "float" %}
    {% include "uscript_encode_dynamic_float.jinja" %}
{% else if field.type == "string" %}
    {% include "uscript_encode_dynamic_string.jinja" %}
{% else %}
    {{ error("invalid type: '", field.type, "' in ", message.name, "_ToMultiBytes") }}
{%- endif -%}

{%- endfor %}
    Bytes[0] = I;
{% endif %}
}

{% if message.always_single_part %}
// Decode single-part {{ message.name }} from bytes.
static final function {{ message.name }}_FromBytes(
    out {{ message.name }} Msg,
    const out byte Bytes[PACKET_SIZE])
{
    // Decode packet payload.
    {% set x = 3 %}
    {% set sz = message.static_size %}

{%- for field in message.fields %}
    {% if field.type == "int" %}
    {% include "uscript_decode_static_int.jinja" %}
    {% set x = var("x", "get") %}
    {% endif %}
{% endfor %}
}
{% endif -%}

// Decode {{ message.name }} from bytes. Decodes both, single-part and multipart messages.
// When decoding multipart messages, Bytes should only contain the packet header once.
// When receiving multipart messages from a socket, the receiver is responsible
// for stripping all "separator" headers. The output of {{ message.name }}_ToMultiBytes
// is a valid input for this function.
static final function {{ message.name }}_FromMultiBytes(
    out {{ message.name }} Msg,
    const out array<byte> Bytes)
{
{% if message.has_string_fields %}
    {% include "uscript_string_decoding_variables.jinja" %}
{% endif %}
    local int I;
    I = 2;
{% for field in message.fields %}
    {% if field.type == "int" %}
    Msg.{{ field.name }} = (
        Bytes[I++]
        | Bytes[I++] << 8
        | Bytes[I++] << 16
        | Bytes[I++] << 24
    );
    {% else if field.type == "byte" %}
    Msg.{{ field.name }} = Bytes[I++];
    {% else if field.type == "float" %}
    Msg.{{ field.name }} = (
        (
            Bytes[I++]
            | (Bytes[I++] << 8)
            | (Bytes[I++] << 16)
            | (Bytes[I++] << 24)
        ) + ((
            Bytes[I++]
            | (Bytes[I++] << 8)
            | (Bytes[I++] << 16)
            | (Bytes[I++] << 24)
        ) / {{ float_multiplier }})
    );
    {% else if field.type == "string" %}
    StrLen = Bytes[I++] >>> 1; // x / 2
    for (StrIdx = 0; StrIdx < StrLen; ++StrIdx)
    {
        Msg.{{ field.name }} $= (Bytes[I++] | (Bytes[I++] << 8));
    }
    {% else if field.type == "bytes" %}
    StrLen = Bytes[I++];
    for (StrIdx = 0; StrIdx < StrLen; ++StrIdx)
    {
        Msg.{{ field.name }} = Bytes[I++];
    }
    {% else %}
    {{ error("invalid type: '", field.type, "' in ", message.name, "_ToMultiBytes") }}
    {% endif %}
{% endfor %}
}

{%- endfor %}
