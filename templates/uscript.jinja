// Generated by uscript_msgbuf_generator. DO NOT EDIT.
class {{ class_name }} extends Object
    abstract
    notplaceable;

enum MessageType
{
{{ uscript_message_type_prefix }}_None,
{% for message in messages %}
    {{ uscript_message_type_prefix }}_{{ message.name }},
{% endfor %}
};

struct ByteWrapper
{
    var byte Bytes[255];
}

// Describes the wire format used by this library.
struct Packet
{
    // Total size of this packet. Packets larger than 255 are sent as multi-part
    // packets. Multi-part packets must be sent in a sequence, until all parts
    // are sent. Multi-part parsing is interrupted if single-part messages are
    // sent while a multi-part message is being parsed. To indicate the end of
    // multi-part sequence, a packet with an empty payload with the following values
    // should be sent: Size=0, Part=0, Type=0 (None).
    var byte Size;

    // 255 for single-part messages. 0-254 for multi-part messages. Incremented
    // for each part. Parts must be sent in an order that matches this field.
    var byte Part;

    // Byte field. Maximum number of supported messages is 254.
    var MessageType Type;

    // Payload bytes. Contains an encoded MessageType message.
    var byte Payload[252];
};

struct Message
{
    // TODO: is this unneeded overhead?
    var MessageType Type;
};

{% for message in messages %}
struct {{ message.name }} extends Message
{
{% for field in message.fields %}
    var {{ field.type }} {{ capitalize(field.name) }};
{% endfor %}
};

{% endfor %}

{% for message in messages %}
{% if message.always_single_part %}
// Encode {{ message.name }} to bytes. Guaranteed to fit in a single packet.
static final function {{ message.name }}_ToBytes(
    const out {{ message.name }} Msg,
    out byte Bytes[255])
{
}
{% endif %}

// Encode {{ message.name }} to bytes. Returns 255 if the message fits in a single packet.
// For multi-part messages, returns the number of parts (2-254).
{% if message.always_single_part %}
// NOTE: This message is always guaranteed to fit in a single packet.
// {{ message.name }}_ToBytes() should be used over this function.
{% endif %}
static final function byte {{ message.name }}_ToMultiBytes(
    const out {{ message.name }} Msg,
    out array<ByteWrapper> Bytes)
{
    return 255;
}

// Decode single-part {{ message.name }} from bytes.
static final function {{ message.name }}_FromBytes(
    out {{ message.name }} Msg,
    const out byte Bytes[255])
{
}

// Decode {{ message.name }} from bytes. Decodes both, single-part and multi-part messages.
static final function {{ message.name }}_FromMultiBytes(
    out {{ message.name }} Msg,
    const out array<ByteWrapper> Bytes)
{
}

{% endfor %}
