{# Copyright (C) 2023  Tuomo Kriikkula #}
{# This program is free software: you can redistribute it and/or modify #}
{#     it under the terms of the GNU Lesser General Public License as published #}
{# by the Free Software Foundation, either version 3 of the License, or #}
{# (at your option) any later version. #}
{# #}
{# This program is distributed in the hope that it will be useful, #}
{#     but WITHOUT ANY WARRANTY; without even the implied warranty of #}
{# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the #}
{# GNU Lesser General Public License for more details. #}
{# #}
{# You should have received a copy of the GNU Lesser General Public License #}
{#     along with this program.  If not, see <https://www.gnu.org/licenses/>. -#}
// Generated by uscript_msgbuf_generator. DO NOT EDIT.
class {{ class_name }} extends Object
    abstract
    notplaceable;

const HEADER_SIZE = {{ header_size }};
const PAYLOAD_SIZE = {{ payload_size }};
const PACKET_SIZE = {{ packet_size }};
const PART_SINGLE_PART = {{ part_single_part }};

const {{ uscript_message_type_prefix }}_None = 0;
{% for message in messages %}
const {{ uscript_message_type_prefix }}_{{ message.name }} = {{ loop.index1 }};
{% endfor %}

// Describes the wire format used by this library.
struct Packet
{
    // Total size of this packet. Packets larger than {{ packet_size }} are sent as multipart
    // packets. multipart packets must be sent in a sequence, until all parts
    // are sent. multipart parsing is interrupted if single-part messages are
    // sent while a multipart message is being parsed. To indicate the end of
    // multipart sequence, a packet with an empty payload with the following values
    // should be sent: Size=0, Part=0, Type=0 ({{ uscript_message_type_prefix }}_None).
    var byte Size;

    // {{ part_single_part }} for single-part messages. 0-254 for multipart messages. Incremented
    // for each part. Parts must be sent in an order that matches this field.
    // The final multipart sequence indicator message has Part set to {{ part_multi_part_end }}.
    var byte Part;

    // 16 bit field. 2 bytes. Maximum number of supported messages
    // is {{ max_message_count }}. 0 is reserved for {{ uscript_message_type_prefix }}_None.
    var int Type;

    // Payload bytes. Contains encoded payload bytes of a Message.
    var byte Payload[PAYLOAD_SIZE];
};

struct Message
{
    // TODO: is this reflection unneeded overhead? How much do we need?
    var int Type;
    var bool HasStaticSize;
    var byte StaticSize;
    var byte StaticPart;
    var bool AlwaysSinglePart;
};

{% for message in messages %}
struct {{ message.name }} extends Message
{
{% for field in message.fields %}
    var {{ uscript_type(field.type) }} {{ capitalize(field.name) }};
{% endfor %}
};

{% endfor -%}

{% for message in messages %}
{% set in_pack = false %}
{% if message.always_single_part %}
// Encode {{ message.name }} to bytes. Guaranteed to fit in a single packet.
static final function byte {{ message.name }}_ToBytes(
    const out {{ message.name }} Msg,
    out byte Bytes[PACKET_SIZE])
{
    {%- set sz = message.static_size %}
    {% set x = 0 %}
    {% include "uscript_encode_static_packet_header.jinja" %}
    {% set x = var_int("x", "get") %}

    // Encode packet payload.
    {%- for field in message.fields %}
    // Field: {{ field.name }}.
    {%- if field.type == "int" %}
    {% include "uscript_encode_static_int.jinja" %}
    {% set x = var_int("x", "get") -%}

    {%- else if field.type == "byte" %}
    Bytes[{{ pad(x, sz) }}{{ x }}] = Msg.{{ field.name }};
    {% set x = x + 1 -%}

    {%- else if field.type == "bool" %}
    {% include "uscript_encode_static_bool.jinja" %}
    {% set x = var_int("x", "get") -%}
    {% set in_pack = var_bool("in_pack", "get") -%}

    {%- else -%}
    {{ error("invalid type: '", field.type, "' in ", message.name, "_ToBytes") }}

    {%- endif -%}

{%- endfor %}

    return {{ x }};
}
{% endif %}

// Encode {{ message.name }} to bytes. If the message does not fit
// in a single packet, the sender is responsible for splitting the
// message into multiple packets. The output of this function is valid
// input for {{ message.name }}_FromMultiBytes.
{% if message.always_single_part %}
// NOTE: This message is always guaranteed to fit in a single packet.
// {{ message.name }}_ToBytes() should be used over this function.
{% endif %}
static final function {{ message.name }}_ToMultiBytes(
    const out {{ message.name }} Msg,
    out array<byte> Bytes)
{
{% set in_pack = false %}
{% if message.has_string_fields %}
    {% include "uscript_string_encoding_variables.jinja" %}
    {% if message.has_float_fields %}
        {% include "uscript_float_coding_variables.jinja" %}
    {% endif %}
{% else if message.has_float_fields %}
    {% include "uscript_string_encoding_variables.jinja" %}
    {% include "uscript_float_coding_variables.jinja" %}
{% endif %}
{% if message.has_bytes_fields %}
    {% include "uscript_bytes_coding_variables.jinja" %}
{% endif %}
{% if message.always_single_part %} {# Just copy buffer for single-part messages. #}
{% set sz = message.static_size %}
    local byte B[PACKET_SIZE];
    Bytes.Length = {{ sz }};
    {{ message.name }}_ToBytes(Msg, B);
{% for i in range(sz) %}
    Bytes[{{ pad(i, sz) }}{{ i }}] = B[{{ pad(i, sz) }}{{ i }}];
{% endfor %}
{% else %} {# Multipart messages. #}

    // Encode packet payload.
{% set sz = message.static_part %}
    local int I;
    // Reserve at least static_part bytes. Grow dynamically if needed.
    Bytes.Length = {{ sz }};
    I = {{ header_size }};
    {% include "uscript_encode_dynamic_packet_header.jinja" %}
{%- for field in message.fields %}
    // Field: {{ field.name }}.
{%- if field.type == "int" %}
    {% include "uscript_encode_dynamic_int.jinja" %}
{% else if field.type == "byte" %}
    Bytes[I++] = Msg.{{ field.name }};
{% else if field.type == "float" %}
    {% include "uscript_encode_dynamic_float.jinja" %}
{% else if field.type == "string" %}
    {% include "uscript_encode_dynamic_string.jinja" %}
{% else if field.type == "bytes" %}
    {% include "uscript_encode_dynamic_bytes.jinja" %}
{% else if field.type == "bool" %}
    {% include "uscript_encode_dynamic_bool.jinja" %}
    {% set in_pack = var_bool("in_pack", "get") %}
{% else %}
    {{ error("invalid type: '", field.type, "' in ", message.name, "_ToMultiBytes") }}
{%- endif -%}

{%- endfor %}
    Bytes[0] = Clamp(I, 0, PACKET_SIZE);
{% endif %}
}

{% if message.always_single_part %}
// Decode single-part {{ message.name }} from bytes.
static final function {{ message.name }}_FromBytes(
    out {{ message.name }} Msg,
    const out byte Bytes[PACKET_SIZE])
{
    // Decode packet payload.
    {% set x = header_size %}
    {% set sz = message.static_size -%}

{% set in_pack = false %}
{%- for field in message.fields %}
    {% if field.type == "int" %}
    {% include "uscript_decode_static_int.jinja" %}
    {% set x = var_int("x", "get") -%}

    {%- else if field.type == "byte" %}
    Msg.{{ field.name }} = Bytes[{{ pad(x, sz) }}{{ x }}];
    {% set x = x + 1 -%}

    {%- else if field.type == "bool" %}
    {% include "uscript_decode_static_bool.jinja" %}
    {% set x = var_int("x", "get") -%}
    {% set in_pack = var_bool("in_pack", "get") -%}

    {%- else if field.type == "string" %}
    {{ error("string not allowed in static message, type: '",
       field.type, "' in ", message.name, "_FromBytes") }}

    {%- else if field.type == "bytes" %}
    {{ error("bytes not allowed in static message, type: '",
       field.type, "' in ", message.name, "_FromBytes") }}

    {%- else  %}
    {{ error("invalid type: '", field.type, "' in ", message.name, "_FromBytes") }}

    {%- endif %}
{% endfor %}
}
{% endif %}

// TODO: potential optimizations:
//   - use hard-coded indices for all fields except dynamic fields
//   - don't increment I if the decoded field is final field of the message
// Decode {{ message.name }} from bytes. Decodes both, single-part and multipart messages.
// When decoding multipart messages, Bytes should only contain the packet header once.
// When receiving multipart messages from a socket, the receiver is responsible
// for stripping all "separator" headers. The output of {{ message.name }}_ToMultiBytes
// is a valid input for this function.
static final function {{ message.name }}_FromMultiBytes(
    out {{ message.name }} Msg,
    const out array<byte> Bytes)
{
{% if message.has_string_fields %}
    {% include "uscript_string_decoding_variables.jinja" %}
    {% if message.has_float_fields %}
        {% include "uscript_float_coding_variables.jinja" %}
    {% endif %}
{% else if message.has_float_fields %}
    {% include "uscript_string_decoding_variables.jinja" %}
    {% include "uscript_float_coding_variables.jinja" %}
{% endif %}
{% if message.has_bytes_fields %}
    {% include "uscript_bytes_coding_variables.jinja" %}
{% endif %}
    local int I;
    I = {{ header_size }};
{% for field in message.fields %}
    {% if field.type == "int" %}
    Msg.{{ field.name }} = (
           Bytes[I++]
        | (Bytes[I++] <<  8)
        | (Bytes[I++] << 16)
        | (Bytes[I++] << 24)
    );
    {# #}
    {%- else if field.type == "byte" %}
    Msg.{{ field.name }} = Bytes[I++];
    {# #}
    {%- else if field.type == "float" %}
    FloatStr = "";
    StrLen = Bytes[I++];
    for (StrIdx = 0; StrIdx < StrLen; ++StrIdx)
    {
        FloatStr $= Chr(Bytes[I++]);
    }
    Msg.{{ field.name }} = float(FloatStr);
    {# #}
    {%- else if field.type == "string" %}
    StrLen = Bytes[I++];
    for (StrIdx = 0; StrIdx < StrLen; ++StrIdx)
    {
        Msg.{{ field.name }} $= Chr(Bytes[I++] | (Bytes[I++] << 8));
    }
    {# #}
    {%- else if field.type == "bytes" %}
    BLen = Bytes[I++];
    Msg.{{ field.name }}.Length = BLen;
    for (BIdx = 0; BIdx < BLen; ++BIdx)
    {
        Msg.{{ field.name }}[BIdx] = Bytes[I++];
    }
    {# #}
    {%- else if field.type == "bool" %}
    {% if bp_is_packed(message, field.name) %}
        {% set bps = message.bool_packs %}
        {% set bpi = bp_pack_index(bps, field.name) %}
    Msg.{{ field.name }} = bool(Bytes[I] & 1{% if bpi > 0 %}{{ " " }}<< {{ bpi }} {% endif %});
        {% if not in_pack %}
            {% set in_pack = true %}
        {% else %}
            {% if bp_is_last(bps, field.name) %}
    ++I;
                {% set in_pack = false %}
            {% else if bp_is_multi_pack_boundary(bps, field.name) %}
    ++I;
            {% endif %}
        {% endif %}
    {% else %}
    Msg.{{ field.name }} = bool(Bytes[I++]);
    {% endif -%}

    {%- else %}
        {{ error("invalid type: '", field.type, "' in ", message.name, "_ToMultiBytes") }}
    {% endif %}
{% endfor %}
}

{%- endfor %}

static final function bool BytesEqual(
    const out array<byte> A,
    const out array<byte> B)
{
    local int I;
    local int L;

    if (A.Length != B.Length)
    {
        return False;
    }

    L = A.Length;
    for (I = 0; I < L; ++I)
    {
        if (A[I] != B[I])
        {
            return False;
        }
    }

    return True;
}

static final function bool IsStaticMessage(int MessageType)
{
    switch (MessageType)
    {
{% for message in messages %}
    case {{ uscript_message_type_prefix }}_{{ message.name }}:
        return {% if message.has_static_size %} True{% else %} False{% endif %};
{% endfor %}
    }

    return False;
}

// TODO: does the engine have built-in comparison for structs?
{% for message in messages %}
static final operator(24) bool == (
    const out {{ message.name }} A,
    const out {{ message.name }} B)
{
    return (
    {% for field in message.fields %}
        {% if field.type == "bytes" %}
        BytesEqual(A.{{ field.name }}, B.{{ field.name }})
        {% else %}
        (A.{{ field.name }} == B.{{ field.name }})
        {% endif %}
        {% if not loop.is_last %}
        &&
        {% endif %}
    {% endfor %}
    );
}

static final operator(26) bool != (
    const out {{ message.name }} a,
    const out {{ message.name }} b)
{
    return !(a == b);
}

{% endfor %}
