{# Copyright (C) 2023-2024  Tuomo Kriikkula #}
{# This program is free software: you can redistribute it and/or modify #}
{#     it under the terms of the GNU Lesser General Public License as published #}
{# by the Free Software Foundation, either version 3 of the License, or #}
{# (at your option) any later version. #}
{# #}
{# This program is distributed in the hope that it will be useful, #}
{#     but WITHOUT ANY WARRANTY; without even the implied warranty of #}
{# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the #}
{# GNU Lesser General Public License for more details. #}
{# #}
{# You should have received a copy of the GNU Lesser General Public License #}
{#     along with this program.  If not, see <https://www.gnu.org/licenses/>. -#}
// Generated by uscript_msgbuf_generator. DO NOT EDIT.

#ifndef {{ upper(class_name) }}_USCRIPT_MSGBUF_GENERATED_HDR_HPP
#define {{ upper(class_name) }}_USCRIPT_MSGBUF_GENERATED_HDR_HPP

#pragma once

#include <cstdint>
#include <span>
#include <string>
#include <vector>
#ifdef UMB_INCLUDE_META
#include <any>
#include <memory>
#endif

#include "umb/umb.hpp"

namespace {{ cpp_namespace }}
{

enum class MessageType : uint16_t
{
    None = 0,
{% for message in messages %}
    {{ message.name }} = {{ loop.index1 }},
{% endfor %}
};

{% for message in messages %}
// TODO: avoid clashes with message field names and reserved identifiers here.
class {{ message.name }} : public ::umb::Message
{
public:
    {{ message.name }}();
    [[nodiscard]] std::vector<::umb::byte> to_bytes() const override;
    [[nodiscard]] bool to_bytes(std::span<::umb::byte> bytes) const override;
    bool from_bytes(std::span<const ::umb::byte> bytes) override;
    [[nodiscard]] size_t serialized_size() const override;
    {% for field in message.fields %}
    [[nodiscard]] {{ cpp_type(field.type) }} {{ field.name }}() const;
    void set_{{ field.name }}({{ cpp_type_arg(field.type) }});
    {% endfor %}
    [[nodiscard]] constexpr uint16_t type() const noexcept override
    {
        return static_cast<uint16_t>(message_type());
    }
    [[nodiscard]] static constexpr MessageType message_type()
    {
        return MessageType::{{ message.name }};
    }
protected:
    [[nodiscard]] bool is_equal(const ::umb::Message& msg) const override;

private:
    {% for field in message.fields %}
    {{ cpp_type(field.type) }} m_{{ field.name }};
        {% if field.type == "float" %}
    std::string m_{{ field.name }}_serialized;
        {% endif %}
    {% endfor %}
};


{% endfor %}

} // {{ cpp_namespace }}

{% if generate_meta_cpp %}
    {% include "cpp_meta.jinja" %}
{% endif %}

#endif // {{ upper(class_name) }}_USCRIPT_MSGBUF_GENERATED_HDR_HPP
