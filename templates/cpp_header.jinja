// Generated by uscript_msgbuf_generator. DO NOT EDIT.

#ifndef {{ upper(class_name) }}_USCRIPT_MSGBUF_GENERATED_HPP
#define {{ upper(class_name) }}_USCRIPT_MSGBUF_GENERATED_HPP

#pragma once

#include "umb/umb.hpp"

namespace {{ cpp_namespace }}
{

enum class MessageType : uint16_t
{
    None = 0,
{% for message in messages %}
    {{ message.name }} = {{ loop.index1 }},
{% endfor %}
};

{% for message in messages %}
// TODO: avoid clashes with message field names and reserved identifiers here.
class {{ message.name }} : public ::umb::Message
{
public:
    {{ message.name }}();
    [[nodiscard]] std::vector<::umb::byte> to_bytes() const override;
    [[nodiscard]] bool to_bytes(std::span<::umb::byte> bytes) const override;
    bool from_bytes(std::span<const ::umb::byte> bytes) override;
    [[nodiscard]] size_t serialized_size() const override;
    {% for field in message.fields %}
    [[nodiscard]] {{ cpp_type(field.type) }} {{ field.name }}() const;
    void set_{{ field.name }}({{ cpp_type_arg(field.type) }});
    {% endfor %}
    friend bool operator==(const {{ message.name }}&, const {{ message.name }}&);
    [[nodiscard]] constexpr MessageType type() const { return MessageType::{{ message.name }}; };
    // TODO: add reflection?

private:
    {% for field in message.fields %}
    {{ cpp_type(field.type) }} m_{{ field.name }};
    {% endfor %}
};

{% endfor %}

} // {{ cpp_namespace }}

#endif // {{ upper(class_name) }}_USCRIPT_MSGBUF_GENERATED_HPP
