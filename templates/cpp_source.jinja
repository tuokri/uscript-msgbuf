{# Copyright (C) 2023  Tuomo Kriikkula #}
{# This program is free software: you can redistribute it and/or modify #}
{#     it under the terms of the GNU Lesser General Public License as published #}
{# by the Free Software Foundation, either version 3 of the License, or #}
{# (at your option) any later version. #}
{# #}
{# This program is distributed in the hope that it will be useful, #}
{#     but WITHOUT ANY WARRANTY; without even the implied warranty of #}
{# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the #}
{# GNU Lesser General Public License for more details. #}
{# #}
{# You should have received a copy of the GNU Lesser General Public License #}
{#     along with this program.  If not, see <https://www.gnu.org/licenses/>. -#}
// Generated by uscript_msgbuf_generator. DO NOT EDIT.

#include <algorithm>
#include <cmath>

#include "{{class_name }}{{ cpp_hdr_extension }}"

namespace
{

UMB_CONSTEXPR bool float_fields_equal(float lhs, float rhs)
{
    if (std::isnan(lhs))
    {
        return std::isnan(rhs);
    }

    if (std::isinf(lhs))
    {
        return std::isinf(rhs);
    }

    // TODO: is this even needed?
    /*
    if (lhs < 0 && rhs < 0)
    {
        return ::umb::internal::approx_equal(lhs, rhs, 0.01f);
    }
    */

    return ::umb::internal::Float{lhs}.AlmostEquals(
        ::umb::internal::Float{rhs});
}

} // namespace

namespace {{ cpp_namespace }}
{

constexpr auto ZERO_SIZE = static_cast<size_t>(0);

{% for message in messages %}
{{ message.name }}::{{ message.name }}()
{% for field in message.fields %}
    {% if loop.is_first %}
    :
    {% else %}
    ,
    {% endif %}
    m_{{ field.name }}({{ cpp_default_value(field.type) }})
    {% if field.type == "float" %}
    , m_{{ field.name }}_serialized{"0"}
    {% endif %}
{% endfor %}
{
}

std::vector<::umb::byte> {{ message.name }}::to_bytes() const
{
    std::vector<::umb::byte> v;
    const auto size = serialized_size();
    v.resize(size);
    auto vi = std::span{v}.begin();
    {% include "cpp_encode_message.jinja" %}
    return v;
}

bool {{ message.name }}::to_bytes(std::span<::umb::byte> bytes) const
{
    const auto size = serialized_size();
    if (!::umb::check_bounds_no_throw(bytes.cbegin(), bytes, size))
    {
        return false;
    }

    auto vi = bytes.begin();
    {% include "cpp_encode_message.jinja" %}

    return true;
}

bool {{ message.name }}::from_bytes(const std::span<const ::umb::byte> bytes)
{
    // TODO: do this without the try-catch?
    //  Set field to default on failure?
    // TODO: actually, use std::expected!
    try
    {
        auto vi = bytes.cbegin();
        if (!::umb::check_bounds_no_throw(vi, bytes, ::umb::g_header_size))
        {
            return false;
        }
        // TODO: verify header? Assume already verified?
        // TODO: do we want a version that only takes the payload bytes?
        std::advance(vi, ::umb::g_header_size);
        {% include "cpp_decode_message.jinja" %}
        return true;
    }
    catch (const std::out_of_range&)
    {
        return false;
    }
}

size_t {{ message.name }}::serialized_size() const
{
{% if message.has_static_size %}
    // TODO: return this value from class reflection data.
    return {{ message.static_size }};
{% else %}
    size_t size = ::umb::g_header_size;
    {% set num_packed_bools = 0 %}
    {% for field in message.fields %}
        {% if field.type == "int" %}
        size += ::umb::g_sizeof_int32; // {{ field.name }}
        {% else if field.type == "byte" %}
        size += ::umb::g_sizeof_byte; // {{ field.name }}
        {% else if field.type == "float" %}
        size += ::umb::g_dynamic_field_header_size;
        size += m_{{ field.name }}_serialized.size(); // {{ field.name }}
        {% else if field.type == "bytes" %}
        size += ::umb::g_dynamic_field_header_size;
        size += m_{{ field.name }}.size(); // {{ field.name }}
        {% else if field.type == "string" %}
        size += ::umb::g_dynamic_field_header_size;
        size += m_{{ field.name }}.size() * ::umb::g_sizeof_uscript_char; // {{ field.name }}
        {% else if field.type == "bool" %}
            {% if bp_is_packed(message, field.name) %}
                {% set pi = bp_pack_index(message.bool_packs, field.name) %}
                {% if bp_is_last(message.bool_packs, field.name) == true %}
                    // TODO: calculate this value at template generation time?
                    size += ::umb::g_sizeof_byte * static_cast<size_t>({{ num_packed_bools }} / {{ bools_in_byte }}) + 1; // {{ field.name }} packed {{ pi }}
                    {% set num_packed_bools = 0 %}
                {% else %}
                    // {{ field.name }} packed {{ pi }}
                    {% set num_packed_bools = num_packed_bools + 1 %}
                {% endif %}
            {% else %}
                size += ::umb::g_sizeof_byte; // {{ field.name }}
            {% endif %}
        {% else %}
            {{ error("invalid type: '", field.type, "' in ", message.name) }}
        {% endif %}
    {% endfor %}
    return size;
{% endif %}
}

{% for field in message.fields %}
{{ cpp_type(field.type) }} {{ message.name }}::{{ field.name }}() const
{
    return m_{{ field.name }};
}

void {{ message.name }}::set_{{ field.name }}({{ cpp_type_arg(field.type) }} value)
{
    {% if field.type == "float" %}
    // TODO: error check here?
    ::umb::encode_float(value, m_{{ field.name }}_serialized);
    {% endif %}
    m_{{ field.name }} = value;
}

{% endfor -%}

bool {{ message.name}}::is_equal(const ::umb::Message& msg) const
{
    const auto& m = static_cast<const {{ message.name }}&>(msg);
    return (
{% for field in message.fields %}
    {% if field.type == "float" %}
        float_fields_equal({{ field.name }}(), m.{{ field.name }}())
    {% else %}
        ({{ field.name }}() == m.{{ field.name }}())
    {% endif %}
        {% if not loop.is_last %} && {% endif %}
{% endfor %}
    );
}

{% endfor %}

} // {{ cpp_namespace }}
