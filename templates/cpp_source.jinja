// Generated by uscript_msgbuf_generator. DO NOT EDIT.

#include <algorithm>

#include "{{class_name }}{{ cpp_hdr_extension }}"

namespace {{ cpp_namespace }}
{

// TODO: just use static_cast<size_t>(0)?
#if defined(WIN32) || defined(_WIN32) || defined(__WIN32) && !defined(__CYGWIN__)
constexpr auto _ZERO = 0ULL;
#else
constexpr auto _ZERO = 0UL;
#endif

{% for message in messages %}
{{ message.name }}::{{ message.name }}()
{% for field in message.fields %}
    {% if loop.is_first %} : {% else %} , {% endif %} m_{{ field.name }}({{ cpp_default_value(field.type) }})
{% endfor %}
{
}

std::vector<::umb::byte> {{ message.name }}::to_bytes() const
{
    std::vector<::umb::byte> v;
    const auto size = serialized_size();
    v.resize(size);
    auto vi = std::span{v}.begin();
    {% include "cpp_encode_message.jinja" %}
    return v;
}

bool {{ message.name }}::to_bytes(std::span<::umb::byte> bytes) const
{
    const auto size = serialized_size();
    if (!::umb::check_bounds_no_throw(bytes.cbegin(), bytes, size))
    {
        return false;
    }

    auto vi = bytes.begin();
    {% include "cpp_encode_message.jinja" %}

    return true;
}

bool {{ message.name }}::from_bytes(const std::span<const ::umb::byte> bytes)
{
    // TODO: do this without the try-catch?
    //  Set field to default on failure?
    try
    {
        auto vi = bytes.cbegin();
        if (!::umb::check_bounds_no_throw(vi, bytes, ::umb::g_header_size))
        {
            return false;
        }
        std::advance(vi, ::umb::g_header_size);
        {% include "cpp_decode_message.jinja" %}
        return true;
    }
    catch (const std::out_of_range&)
    {
        return false;
    }
}

size_t {{ message.name }}::serialized_size() const
{
    size_t size = ::umb::g_header_size;
{% set num_packed_bools = 0 %}
{% for field in message.fields %}
    {% if field.type == "int" %}
    size += ::umb::g_sizeof_int32; // {{ field.name }}
    {% else if field.type == "byte" %}
    size += ::umb::g_sizeof_byte; // {{ field.name }}
    {% else if field.type == "float" %}
    size += ::umb::g_sizeof_float; // {{ field.name }}
    {% else if field.type == "bytes" %}
    size += ::umb::g_dynamic_field_header_size;
    size += m_{{ field.name }}.size(); // {{ field.name }}
    {% else if field.type == "string" %}
    size += ::umb::g_dynamic_field_header_size;
    size += m_{{ field.name }}.size() * ::umb::g_sizeof_uscript_char; // {{ field.name }}
    {% else if field.type == "bool" %}
        {% if bp_is_packed(message, field.name) %}
            {% set pi = bp_pack_index(message.bool_packs, field.name) %}
            {% if bp_is_last(message.bool_packs, field.name) == true %}
                size += ::umb::g_sizeof_byte * static_cast<size_t>({{ num_packed_bools }} / {{ bools_in_byte }}) + 1; // {{ field.name }} packed {{ pi }}
                {% set num_packed_bools = 0 %}
            {% else %}
                // {{ field.name }} packed {{ pi }}
                {% set num_packed_bools = num_packed_bools + 1 %}
            {% endif %}
        {% else %}
            size += ::umb::g_sizeof_byte; // {{ field.name }}
        {% endif %}
    {% else %}
        {{ error("invalid type: '", field.type, "' in ", message.name) }}
    {% endif %}
{% endfor %}
    return size;
}

{% for field in message.fields %}
{{ cpp_type(field.type) }} {{ message.name }}::{{ field.name }}() const
{
    return m_{{ field.name }};
}

void {{ message.name }}::set_{{ field.name }}({{ cpp_type_arg(field.type) }} value)
{
    m_{{ field.name }} = value;
}

{% endfor %}

bool operator==(const {{ message.name }} & lhs, const {{ message.name }}& rhs)
{
    return (
{% for field in message.fields %}
        (lhs.{{ field.name }}() == rhs.{{ field.name }}()) {% if not loop.is_last %} && {% endif %}
{% endfor %}
    );
}

{% endfor %}

} // {{ cpp_namespace }}
